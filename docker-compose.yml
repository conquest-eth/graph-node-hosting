version: '3.3'

# secrets:
#   cloudflare_dns_token:
#     file: "./secrets/cloudflare_dns_token.secret"

services:
  traefik:
    image: "traefik:v2.5"
    container_name: "traefik"
    command:
      # - "--log.level=DEBUG"
      # - "--api.insecure=true" # dashboard on 8080

      # docker
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"

      # endpoints:
      - "--entrypoints.web.address=:80" # open the port 80 and name it web (http)
      - "--entrypoints.websecure.address=:443" # open the port 443 and name it websecure (https)

      # Enable a dns challenge named "myresolver"
      - "--certificatesresolvers.myresolver.acme.dnschallenge=true"
      # Tell which provider to use
      - "--certificatesresolvers.myresolver.acme.dnschallenge.provider=cloudflare"

      # staging env to test
      #- "--certificatesresolvers.myresolver.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory"

      # The email to provide to let's encrypt
      - "--certificatesresolvers.myresolver.acme.email=$LETS_ENCRYPT_EMAIL"

      # Tell to store the certificate on a path under our volume
      - "--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json"

      # redirect to https
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"

      # Enable dashboard
      - "--api.dashboard=true"

    labels:
      - "traefik.enable=true"

      - "traefik.http.routers.traefik.service=api@internal"
      - "traefik.http.routers.traefik.rule=Host(`traefik.$APP_HOST`)"
      - "traefik.http.routers.traefik.entrypoints=websecure"
      - "traefik.http.routers.traefik.tls.certresolver=myresolver"

      # add authentication
      - "traefik.http.routers.traefik.middlewares=traefik-auth"
      - "traefik.http.middlewares.traefik-auth.basicauth.users=$BASIC_AUTHENTICATION"


    ports:
      - "80:80" # expose 80 on 80 (web entrypoint)
      - "443:443" # expose 443 on 443 (websecure entrypoint)
    # secrets:
    #   - "cloudflare_dns_token"
    environment:
      # - "CF_DNS_API_TOKEN_FILE=/run/secrets/cloudflare_dns_token"
      - "CF_DNS_API_TOKEN=$CF_DNS_API_TOKEN"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"

      # Create a letsencrypt dir within the folder where the docker-compose file is
      # DATA_PATH is needed when used in remote with --context
      - "${DATA_PATH}/letsencrypt/$APP_HOST:/letsencrypt"

  hello:
    image: shubhag/hello-world-node
    container_name: "hello-world-node"
    labels:
      - "traefik.enable=true"

      - "traefik.http.routers.hello.entrypoints=websecure"
      - "traefik.http.routers.hello.rule=Host(`hello.$APP_HOST`)"
      - "traefik.http.routers.hello.tls.certresolver=myresolver"

      # - "traefik.http.services.hello.loadbalancer.server.port=8080" # not needed as traefik will detect it as the only open port
    # ports:
      # - '8888:8080' #expose 8888 and make it talk to 8080 on that service, (bypass traefik)

  whoami:
    image: "traefik/whoami"
    container_name: "whoami"
    labels:
      - "traefik.enable=true"

      - "traefik.http.routers.whoami.entrypoints=websecure"
      - "traefik.http.routers.whoami.rule=Host(`whoami.$APP_HOST`)"
      - "traefik.http.routers.whoami.tls.certresolver=myresolver"

  test:
    image: "traefik/whoami"
    container_name: "test"
    labels:
      - "traefik.enable=true"

      - "traefik.http.routers.test.entrypoints=websecure"
      - "traefik.http.routers.test.rule=Host(`$APP_HOST`)"
      - "traefik.http.routers.test.tls.certresolver=myresolver"


#   graph-node:
#     image: graphprotocol/graph-node
#     ports:
#       - '8000:8000'
#       - '8001:8001'
#       - '8020:8020'
#       - '8030:8030'
#       - '8040:8040'
#     depends_on:
#       - ipfs
#       - postgres
#     environment:
#       postgres_host: postgres
#       postgres_user: graph-node
#       postgres_pass: let-me-in
#       postgres_db: graph-node
#       ipfs: 'ipfs:5001'
#     #   ethereum: 'mainnet:http://host.docker.internal:8545'
#       ethereum: 'goerli:https://eth-goerli.alchemyapi.io/v2/zn8Q6SPEPmpWIiZnbnXXNgRxDCrkybJp'
#       GRAPH_LOG: info

# #   graph-node-query:

#   ipfs:
#     image: ipfs/go-ipfs:v0.4.23
#     ports:
#       - '5001:5001'
#     volumes:
#       - ./data/ipfs:/data/ipfs

#   postgres:
#     image: postgres
#     ports:
#       - '5432:5432'
#     command: ["postgres", "-cshared_preload_libraries=pg_stat_statements"]
#     environment:
#       POSTGRES_USER: graph-node
#       POSTGRES_PASSWORD: let-me-in
#       POSTGRES_DB: graph-node
#     volumes:
#       - ./data/postgres:/var/lib/postgresql/data

